#include "simulation.h" 
Simulation::Simulation()
{
  // Create the initial frame work for the network mesh.
    m_mesh = new NetworkMesh(10);

  // Packet size current and max
    m_currentPackets = 0;
    m_maxPackets = 0;

    m_currentNodes = 0;

  // Set the timer to zero
    m_currTime = 0;
    m_termTime = 0;

  // Packet send buffer generated by build simulation. Set to NULL on simulation construstion.
    m_sendBuffer = NULL;

}

Simulation::Simulation(const Simulation& mesh)
{

}

Simulation::~Simulation()
{
  if( m_mesh !=  NULL) 
    delete m_mesh;
  m_mesh = NULL;

  if( m_sendBuffer != NULL)
    delete []m_sendBuffer;
  m_sendBuffer = NULL; 
}

bool Simulation::buildSimulation()
{

  // Declare and Initialize variables
    int index = 0;
    char userInput = '0';
    bool buildSim = true;
    NetworkNode temp;
    Packet pkt;
   


// Test initialization of packet
  pkt.setSrcId(0);
  pkt.setDestId(1);
  pkt.setData(10);
 

  

// Test function

temp.setThroughput(0.1);

//cout << temp;


addNodeToMesh(temp);

temp.setThroughput(0.3);

addNodeToMesh(temp);

establishLink(0,1);

m_sendBuffer = new Packet[1];
m_sendBuffer[0] = pkt;



 
  // Loop through build simulation menu
  while( buildSim )
  {

    cout << "Option 1. Upload nodes from Mesh. " << '\n';
    cout << "Option 2. Create nodes for mesh by hand. " << '\n';
    cout << "Option 3. Option space available. " << '\n';
    cout << "Option 4. Packet Builder. " << '\n';
    cout << "Option 5. Packet Generator. " << '\n';
    cout << "Option 6. Exit Builder. " << '\n';

    cin >> userInput;

    // Ask for user input
    switch(userInput)
    {

      // switch based on input
      case '1': buildMeshFromFile();
             break;
 
      case '2': // `
             break;

      case '3': //
             break;

      case '4': // Packet Builder: Only if two valid nodes exist in the mesh.
                // create packet.
                // load packet into packet buffer.
             break;

      case '5': 
             break;
  
      case '6': buildSim = false;
             break;
 
        // Option 4. Packet Builder : Only if two valid nodes exist in the mesh.

        // Option 5. Packet Generator : Only if two valid nodes exist in the mesh.
    }
  }
   // stubb function
   return false;

}


bool Simulation::addNodeToMesh(const NetworkNode& node)
{

  // Declare and Initialize variables
    int index = 0;

  // if there is room in the mesh add the node to the mesh
    if( m_mesh->getCurrentNumOfNodes() < m_mesh->getMaxNumOfNodes())
    {

      // Add node 
 

      // Provide the Node id. The Node Id must be in sync with the node registry to provide
        // quick access.
        m_mesh->addNode(node);
        (*m_mesh)[m_currentNodes].setNodeID(m_currentNodes);
      cout << "Node Data for current set ID sim.cpp line 143: " << (*m_mesh)[m_currentNodes];
      // Currents increase
      m_currentNodes++;



    }
  // else report false 


  // function stubb
  return false;
}

bool Simulation::establishLink(const int& src, const int& dest)
{
  // Declare and Initialize variables

  // link the nodes if they exist in the node registry.
  
     m_mesh->linkNodes(src,dest);
      
    //  

  // function stubb
  return false;
}


bool Simulation::packetGenerator()
{
   // Declare and Initialize variables
  
     // Randomize Src and Dest

     // Randomize data

     // Randomize unique packet characteristics


  // stubb return
    return false;
}


bool Simulation::packetBuilder()
{

  // Declare and Initialize varaibles

    // Direct the User through Packet build process. If we can add a packet

      // Step 1. Request source for the packet. Check if its valid

      // Step 2. Request destination for the pack. Check it its valid

      // Step 3. Request user for unqiue packet details

      // We must determine if we can add another packet
 
        // if yes then ask user: "Would you like to add another packet?"
 
        // else no then tell user: "There is no longer any space for another packet."


   return false;
}

bool Simulation::run(int runLength)
{
  // Declare and initialize simulation parameters

    // Mesh iterator used to iterate through the mesh and update each node. 
      int meshUpdateIterator = 0;
    // Standardize time for stability and simulation time initialization.
      time_t standardDelta = 0.2;
      m_currTime = 0.0;
      m_termTime = runLength;
 
    // Secure Throughput setting: 1 second. 
      int secure_throughput = 0.3;
      
  // Obtain current time
// TODO: Move to update function.
  // Loop until termination time
  while( m_currTime < m_termTime)
  { 
    // Check security information from reports sent to simulation.
       // If a node has been compromised the node will be improved from the mesh.
         // The links associated with the node will be removed.
         // The mesh will enter a lower throughput to prevent information from spreading this occurs if the node is remove or not.
         // Assumption: ALL NODES CAN REPORT to the master secure node(node registry)  FASTER THAN THERE THROUGHPUT. 

    // We need to check the build frame for packets to send at every tick.
 
      // If we have a packet to send the packet.
        // Example: NodeA send packet to NodeC at time 0.3. The tick will occur at 0,0.2,0.4
                 // The packet will be sent at 0.4 for simulation stability.
                 //  
        if( m_currentPackets > CONST_NO_PACKETS)
        {
          // Assume: At 0.0 all packets(in this test sim case, 1 packet) will be loaded into the node
             // This packet will be sent by the source node during this first update.

          // send packet // TODO:The constant literal 0 will become an iterator later.
            if( m_sendBuffer != NULL)
            {
              // This loads the packet from the send buffer to the network node.
                ((*m_mesh)[m_sendBuffer[0].getSrcId()]).setPacket(m_sendBuffer[0]);
            }
            // remove from buffer
            m_currentPackets--; 
        }  
    // We need to tick the node mesh ever time step. 
      for(meshUpdateIterator = 0; meshUpdateIterator < m_mesh->getCurrentNumOfNodes(); meshUpdateIterator++)
      {

        // update each network node in the mesh.
          if(m_mesh[meshUpdateIterator].update(standardDelta))
          {
            // Premature end of simulation, we are simulating the optimal throughput send of one packet
            m_currTime = m_termTime;
            
            // report data for received packet/last send function called.
              // m_mesh[meshUpdateIterator] this happens report happens when the packet 
              // reaches the received node. At the network Node level. 
 

          }

      }
    // The packets will be place into the source buffers at certain times.
    
    // These packets will be sent at certain times.

    // Packets that are sent will be received at certain times.
    
    // Update current time by delta
      m_currTime += standardDelta; 
  }

  // func stubb 
    return false;
}

bool Simulation::update(time_t delta)
{
  // Decalre and Initialize variables

  // handle simulation events

  // Update each node in the node registry
    // each update will generate an update report this report will contain the path to get to a node
    // and throughput information.

  // if a node in the registry returns true then we know the update reported a truth. The packet
    // was received. //TODO: message reporting

  // The only way to determine the overall max throughput for a network is to understand the paths inside the network. The max throughput for a network changes depending on the path. The max throughput in our case will be the max throughput that the network generates after x amount of packets sent. 

  // The routing protocol is Dynamic source routing mixed with master node reporting. Once the packet
  // arrives to its destination it reports its arrival. The quickest path will report the arrival of 
  // the packet first. This instant reporting allows us to determine the quickest path.


  // func stubb
  return false;
}

bool Simulation::sendPackets()
{

  // Declare and Initialzie variables

  // TODO: Send packets can send at certain times, but for now it will just load packets into the source
     //      nodes.

  // Iterate through the packet array and send packets

     // Determine the source node and load the packet into the src node

     // This loading will occur at initialization of the simulation prior to the first time tick at 0.0seconds.
 
  // func stubb
    return false;
}

NetworkMesh Simulation::getNetworkMesh()const
{
  return *m_mesh;
}

int Simulation::getCurrentPackets()const
{
    return m_currentPackets;
}

int Simulation::getMaxPackets()const
{
    return m_maxPackets;

}


void Simulation::buildMeshFromFile()
{
    int numOfNodes;
    int numOfLinks;
    int tempInt;
    bool tempBool;
    double tempDouble;
    NetworkNode temp;
    ifstream simFile;
    char* fileInput = new char[MAX_CSTRING_SIZE];
    char wait = '0';
    //open the file and extract number of nodes in mesh
    simFile.open("simFile.txt");
    simFile.ignore(256, ':');
    simFile >> numOfNodes;

    //loop through for each node in file
    for(int i = 0; i < numOfNodes; i++)
    {
        //set node ID
        simFile >> fileInput;
        cout << fileInput;
        simFile >> fileInput;
        cout << fileInput;
        simFile >> tempInt;
        temp.setNodeID(tempInt);
        
        simFile >> fileInput;
        cout << fileInput;
        simFile >> fileInput;
        cout << fileInput;
        simFile >> tempInt;
        
        //set number of links;
        simFile >> fileInput;
        simFile >> numOfLinks;
        temp.setNumOfLinks(numOfLinks);
        //set wifi feature
        simFile.ignore(256, ':');
        simFile >> tempBool;
        temp.setWifiEnabled(tempBool);
        //set processing delay
        simFile.ignore(256, ':');
        simFile >> tempDouble;
        temp.setProcessingDelay(tempDouble);
        //set transmission delay
        simFile.ignore(256, ':');
        simFile >> tempDouble;
        temp.setTransmissionDelay(tempDouble);
        //set queue delay
        simFile.ignore(256, ':');
        simFile >> tempDouble;
        temp.setQueueDelay(tempDouble);
        //set propragation delay
        simFile.ignore(256, ':');
        simFile >> tempDouble;
        temp.setPropagationDelay(tempDouble);
        //set wifi range
        simFile.ignore(256, ':');
        simFile >> tempDouble;
        temp.setWifiRange(tempDouble);
        //set IPV6 feature
        simFile.ignore(256, ':');
        simFile >> tempBool;
        temp.setIPV6(tempBool);
        //set the location
        simFile.ignore(256, ':');

        //add the node to the mesh
        m_mesh->addNode(temp);
    }

                ((*m_mesh)[m_sendBuffer[0].getSrcId()]).setPacket(m_sendBuffer[0]);
    int idA, idB;
    for(int i = 0; i < numOfNodes; i++)
    {
        simFile.ignore(256, ':');
        for(int j = 0; j < ((*m_mesh)[i].getNumOfLinks()); j++)
        {
            simFile.ignore(256, ':');
            simFile >> idA;
            simFile.ignore(256, ':');
            simFile >> idB;
        //    m_mesh->nodeRegistry[i].setLink(m_mesh->nodeRegistry[idB]);
            simFile.ignore(256, ':');
            simFile >> tempDouble;
         //   m_mesh->nodeRegistry[i].setThroughput(tempDouble);
        }
    }
}

bool Simulation::uploadMesh(ifstream& fin, char fileName[MAX_CSTRING_SIZE])
{
  // Declare and Initialize variables
    char* fileInput = new char[MAX_CSTRING_SIZE]; 
  // Open file
    fin.open(fileName); 
  // If the file is good continue, else report false,

  if( !fin.good())
  {
    cout << "Error!";

    return false;
  }

  while(fin.good())
  {
    fin >> fileInput; 

  }



}


ostream& operator<<(ostream& os, const Simulation& sim)
{

   os << "Simulation Data: " << '\n';
   os << "Network Mesh Data: " << sim.getNetworkMesh() << '\n';


  return os;
}
