#include "simulation.h" 
Simulation::Simulation()
{
  // Create the initial frame work for the network mesh.
    m_mesh = new NetworkMesh(10);

  // Packet size current and max
    m_currentPackets = 0;
    m_maxPackets = 0;

    m_currentNodes = 0;

  // Set the timer to zero
    m_currTime = 0;
    m_termTime = 0;

  // Packet send buffer generated by build simulation. Set to NULL on simulation construstion.
    m_sendBuffer = NULL;

}

Simulation::Simulation(const Simulation& mesh)
{
  // Temporary function //TODO: may not be needed
}

Simulation::~Simulation()
{
  if( m_mesh !=  NULL) 
    delete m_mesh;
  m_mesh = NULL;

  if( m_sendBuffer != NULL)
    delete []m_sendBuffer;
  m_sendBuffer = NULL; 
}

bool Simulation::buildSimulation()
{

  // Declare and Initialize variables
    int index = 0;
    char userInput = '0';
    bool buildSim = true;
 
  // Loop through build simulation menu
  while( buildSim )
  {

    cout << "Option 1. Upload nodes from Mesh. " << '\n';
    cout << "Option 2. Create nodes for mesh by hand. " << '\n';
    cout << "Option 3. Option space available. " << '\n';
    cout << "Option 4. Packet Builder. " << '\n';
    cout << "Option 5. Packet Generator. " << '\n';
    cout << "Option 6. Exit Builder. " << '\n';

    cin >> userInput;

    // Ask for user input
    switch(userInput)
    {

      // switch based on input
      case '1': // upload nodes from file to mesh
             break;
 
      case '2': // `
             break;

      case '3': //
             break;

      case '4': // Packet Builder: Only if two valid nodes exist in the mesh.
             break;

      case '5': 
             break;
  
      case '6': buildSim = false;
             break;
 
        // Option 4. Packet Builder : Only if two valid nodes exist in the mesh.

        // Option 5. Packet Generator : Only if two valid nodes exist in the mesh.
    }
  }
   // stubb function
   return false;

}


bool Simulation::addNodeToMesh(const NetworkNode& node)
{

  // Declare and Initialize variables
    int index = 0;

  // if there is room in the mesh add the node to the mesh
    if( m_mesh->getCurrentNumOfNodes() < m_mesh->getMaxNumOfNodes())
    {

      // Add node 
      m_mesh->addNode(node);

    }
  // else report false 


  // function stubb
  return false;
}

bool Simulation::establishLink(int& src, int& dest)
{
  // Declare and Initialize variables

  // link the nodes if they exist in the node registry.
  
     m_mesh->linkNodes(src,dest);
      
    //  

  // function stubb
  return false;
}


bool Simulation::packetGenerator()
{
   // Declare and Initialize variables
  
     // Randomize Src and Dest

     // Randomize data

     // Randomize unique packet characteristics


  // stubb return
    return false;
}


bool Simulation::packetBuilder()
{

  // Declare and Initialize varaibles

    // Direct the User through Packet build process. If we can add a packet

      // Step 1. Request source for the packet. Check if its valid

      // Step 2. Request destination for the pack. Check it its valid

      // Step 3. Request user for unqiue packet details

      // We must determine if we can add another packet
 
        // if yes then ask user: "Would you like to add another packet?"
 
        // else no then tell user: "There is no longer any space for another packet."


   return false;
}

bool Simulation::run(int runLength)
{
  // Declare and initialize simulation parameters

    // Mesh iterator used to iterate through the mesh and update each node. 
    int meshUpdateIterator = 0;

    // Standardize time for stability and simulation time initialization.
      time_t standardDelta = 0.2;
      m_currTime = 0.0;
      m_termTime = runLength; 
    // Secure Throughput setting: 1 second. 
      int secure_throughput = 0.3;
      
  // Obtain current time
// TODO: Move to update function.
  // Loop until termination time
  while( m_currTime < m_termTime)
  { 
    // Check security information from reports sent to simulation.
       // If a node has been compromised the node will be improved from the mesh.
         // The links associated with the node will be removed.
         // The mesh will enter a lower throughput to prevent information from spreading this occurs if the node is remove or not.
         // Assumption: ALL NODES CAN REPORT to the master secure node(node registry)  FASTER THAN THERE THROUGHPUT. 

    // We need to check the build frame for packets to send at every tick.
 
      // If we have a packet to send the packet.
        // Example: NodeA send packet to NodeC at time 0.3. The tick will occur at 0,0.2,0.4
                 // The packet will be sent at 0.4 for simulation stability.
                 //  
        if( m_currentPackets > CONST_NO_PACKETS)
        {
          // Assume: At 0.0 all packets(in this test sim case, 1 packet) will be loaded into the node
             // This packet will be sent by the source node during this first update.

          // send packet
            m_mesh[m_currentPacket[0].getSrcId()].setPacket(m_currentPacket[0]);

            // remove from buffer
            m_currentPacket--; 
        }  
    // We need to tick the node mesh ever time step. 
      for(meshUpdateIterator = 0; meshUpdateIterator < m_mesh->getCurrentNumOfNodes(); meshUpdateIterator++)
      {

        // update each network node in the mesh.
          if(m_mesh[meshUpdateIterator].update(standardDelta))
          {
            // Premature end of simulation, we are simulating the optimal throughput send of one packet
            m_currTime = m_termTime;
            
            // report data for received packet/last send function called.
              // m_mesh[meshUpdateIterator] this happens report happens when the packet 
              // reaches the received node. At the network Node level. 
 

          }

      }
    // The packets will be place into the source buffers at certain times.
    
    // These packets will be sent at certain times.

    // Packets that are sent will be received at certain times.
    
    // Update current time by delta
      m_currTime += standardDelta; 
  }

  // func stubb 
    return false;
}

bool Simulation::update(time_t delta)
{
  // Decalre and Initialize variables

  // handle simulation events

  // Update each node in the node registry
    // each update will generate an update report this report will contain the path to get to a node
    // and throughput information.

  // if a node in the registry returns true then we know the update reported a truth. The packet
    // was received. //TODO: message reporting

  // The only way to determine the overall max throughput for a network is to understand the paths inside the network. The max throughput for a network changes depending on the path. The max throughput in our case will be the max throughput that the network generates after x amount of packets sent. 

  // The routing protocol is Dynamic source routing mixed with master node reporting. Once the packet
  // arrives to its destination it reports its arrival. The quickest path will report the arrival of 
  // the packet first. This instant reporting allows us to determine the quickest path.


  // func stubb
  return false;
}

bool Simulation::sendPackets()
{

  // Declare and Initialzie variables

  // TODO: Send packets can send at certain times, but for now it will just load packets into the source
     //      nodes.

  // Iterate through the packet array and send packets

     // Determine the source node and load the packet into the src node

     // This loading will occur at initialization of the simulation prior to the first time tick at 0.0seconds.
 
  // func stubb
    return false;
}

NetworkMesh Simulation::getNetworkMesh()const
{
  return *m_mesh;
}

int Simulation::getCurrentPackets()const
{
    return m_currentPackets;
}

int Simulation::getMaxPackets()const
{
    return m_maxPackets;

}



ostream& operator<<(ostream& os, const Simulation& sim)
{

   os << "Simulation Data: " << '\n';
   os << "Network Mesh Data: " << sim.getNetworkMesh() << '\n';


  return os;
}
